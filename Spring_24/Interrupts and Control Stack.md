---
aliases:
  - Interrupts
  - Computer System Overview
  - Interrupt Descriptor Table
---
# Interrupts

When a CPU is disrupted by an interrupt, it means that the normal flow of execution is temporarily halted, and the CPU shifts its attention to handle an external event or request. Interrupts are signals generated by hardware devices or software to notify the CPU that a specific event has occurred and requires attention. This mechanism allows the CPU to efficiently handle various tasks concurrently.

Here is an overview of what happens when a [[CPU]] is disrupted by an interrupt:

1. **Interrupt Request (IRQ):**
   - An interrupt is initiated by an external device or a software process. This can include hardware events like a keyboard input, timer expiration, or I/O completion, or software-generated interrupts for system calls or exceptions.

2. **Interrupt Signal:**
   - The interrupt signal is sent to the CPU, prompting it to temporarily suspend the current execution and switch to an interrupt handling routine.

3. **Interrupt Service Routine (ISR):**
   - The CPU transfers control to a predefined Interrupt Service Routine (ISR) or interrupt handler. The ISR is a piece of code specifically designed to handle the interrupt.

4. **Save Context:**
   - Before jumping to the ISR, the CPU often saves the current context, including the program counter, register values, and other relevant information. This ensures that the interrupted program can later resume its execution from the point of interruption.

5. **Execute ISR:**
   - The CPU executes the ISR, which contains the instructions to handle the specific interrupt. The ISR may involve processing data, interacting with devices, or performing other tasks related to the interrupt's cause.

6. **Restore Context:**
   - Once the ISR completes its execution, the CPU restores the saved context, including the program counter and register values, to allow the interrupted program to continue from where it left off.

7. **Resume Execution:**
   - The CPU resumes the interrupted program, continuing its normal execution.

Interrupts are crucial for handling asynchronous events in a computer system without wasting CPU cycles on continuously polling for events. They enable the CPU to respond promptly to external events and improve the overall efficiency of the system.

Now, regarding the control stack:

The control stack, often referred to as the call stack or execution stack, is a region of memory used to manage the flow of program execution and store information related to function calls and interrupts. It is essential for supporting the execution of multiple functions or tasks and handling nested calls.

Key features of the control stack:

1. **Function Call Management:**
   - When a function is called, information about the current execution state, including the return address (the address to resume execution after the function call), local variables, and other relevant data, is pushed onto the control stack.

2. **Nested Calls:**
   - The stack allows for the nesting of function calls. When a function calls another function, a new set of information is pushed onto the stack, allowing the inner function to execute independently of the outer function.

3. **Interrupt Handling:**
   - During an interrupt, the control stack is used to save the current context of the interrupted program. This ensures that the program can resume its execution seamlessly after handling the interrupt.

4. **Stack Frames:**
   - Each function call or interrupt generates a stack frame, a portion of the stack that contains information specific to that function or interrupt. The stack frames are organized in a last-in, first-out (LIFO) fashion.

5. **Stack Pointer:**
   - The stack pointer is a register that points to the top of the stack. It is adjusted as items are pushed or popped from the stack.

The control stack plays a crucial role in managing the execution flow, supporting function calls, handling interrupts, and maintaining the integrity of the program's execution context. It is a fundamental data structure used by CPUs and programming languages to facilitate structured and organized program execution.

# [[Interrupt Descriptor Table]]

The IDT, or Interrupt Descriptor Table, is a data structure used in the x86 architecture to define the interrupt and exception handlers for the processor. It plays a crucial role in managing and responding to various events that can interrupt the normal flow of program execution. The IDT is part of the interrupt handling mechanism in the x86 family of processors.

Here are the key points about the IDT:

### 1. **Purpose:**

- **Interrupt Handling:**
  - The primary purpose of the IDT is to provide a table of interrupt vectors, each associated with a specific interrupt or exception. When an interrupt or exception occurs, the processor uses the IDT to find the corresponding interrupt service routine (ISR) or exception handler.

### 2. **Structure:**

- **Vector Entries:**
  - The IDT is an array of entries, each corresponding to a specific interrupt or exception. Each entry is known as a vector and contains information about the location of the associated ISR or handler.

- **Vector Numbers:**
  - The position of an entry in the IDT is identified by a vector number. This number is used by the processor to index into the IDT when an interrupt occurs.

### 3. **Interrupt Descriptor:**

- **Format:**
  - Each entry in the IDT is an Interrupt Descriptor, which is a data structure that contains information such as the base address of the ISR, the code segment selector, and various flags.

- **Descriptor Types:**
  - There are different types of descriptors in the IDT, including interrupt gates, trap gates, and task gates, each serving specific purposes.

### 4. **Interrupt Gates vs. Trap Gates:**

- **Interrupt Gates:**
  - Used for hardware interrupts. When an interrupt occurs, the processor saves the current execution context and jumps to the ISR specified in the interrupt gate.

- **Trap Gates:**
  - Used for software interrupts or exceptions generated by the processor's instruction set. Like interrupt gates, trap gates transfer control to the specified ISR but do not disable interrupts during the process.

### 5. **Exception Handling:**

- **Exception Handling in Protected Mode:**
  - In protected mode (a mode of operation in x86 processors), exceptions (such as divide-by-zero or page faults) are handled through the IDT.

- **Exception Handling in Real Mode:**
  - In real mode, exceptions and interrupts are handled through a similar table known as the Interrupt Vector Table (IVT).

### 6. **Loading the IDT:**

- **Programming the IDT:**
  - Operating systems or low-level software typically initialize the IDT during system initialization. They provide the base address of the IDT and set up the individual interrupt or exception handlers.

- **Loading the IDT Register:**
  - The processor has a special register called the Interrupt Descriptor Table Register (IDTR), which holds the base address and the limit (size) of the IDT. Loading the IDTR register effectively loads the IDT into the system.

### 7. **User-Mode and Kernel-Mode Transitions:**

- **Gate Descriptors and Privilege Levels:**
  - The IDT includes gate descriptors that specify the privilege level required to execute the associated ISR. This helps control transitions between user mode and kernel mode.

### 8. **Role in Context Switching:**

- **Context Switching:**
  - During a context switch, the IDT plays a role in saving and restoring the processor's state, ensuring a smooth transition between different execution contexts.

### 9. **Security Implications:**

- **Security Measures:**
  - Proper configuration of the IDT is crucial for system security. By controlling access to interrupt vectors, the IDT helps prevent unauthorized or malicious code execution.

### 10. **Operating System Independence:**

- **Operating System-Specific:**
  - The IDT is part of the architecture, and its structure and usage may vary between different operating systems. Operating systems set up their own ISRs and IDTs during initialization.

Understanding the IDT is essential for system programmers, kernel developers, and those working on low-level system software. It is a fundamental component in managing interrupts and exceptions, which are critical for the stability and functionality of a computer system.

# Stack vs. Control Stack
The terms "stack" and "control stack" are often used interchangeably, but it's important to note that they can have different contexts and meanings depending on the context in which they are used. In general, the term "stack" refers to a data structure that follows the Last-In, First-Out (LIFO) principle, and it can be used in various contexts, including both data storage and program execution. The "control stack" specifically refers to the stack used for managing program execution, particularly in the context of function calls and interrupts. Let's explore the differences between the two:

### Stack (Data Structure):

1. **General Concept:**
   - In computer science, a "stack" is a fundamental data structure that follows the Last-In, First-Out (LIFO) principle. It is a collection of elements with two main operations: push (adding an element to the top of the stack) and pop (removing the top element from the stack).

2. **Data Storage:**
   - Stacks can be used for various purposes in data storage. For example, they are employed in algorithms, such as depth-first search in graph traversal, expression evaluation, and managing undo/redo functionality in applications.

3. **Memory Management:**
   - Stacks are used in memory management, such as in the call stack, where local variables and function call information are stored during program execution.

4. **Implementation:**
   - Stacks can be implemented using arrays, linked lists, or other data structures, and they have a wide range of applications in computer science beyond program execution.

### Control Stack (Call Stack):

1. **Specific Context:**
   - The term "control stack" is more specific and often refers to the stack used for managing program control flow, specifically in the context of function calls, interrupts, and program execution.

2. **Function Calls:**
   - During function calls, information about the current execution state, including the return address, local variables, and other relevant data, is stored in the control stack in the form of stack frames.

3. **Interrupt Handling:**
   - When an interrupt occurs, the control stack is used to save the context of the interrupted program, allowing it to resume execution seamlessly after handling the interrupt.

4. **Program Execution:**
   - The control stack is an essential component of program execution and facilitates the orderly flow of control between different parts of a program.

5. **Examples:**
   - Examples of control stacks include the call stack in a programming language like C or the system stack in the context of an operating system.

In summary, while the term "stack" can refer to a general data structure with various applications, the term "control stack" is often used specifically in the context of program control flow, such as function calls and interrupts. The control stack is a subset of the broader concept of stacks and plays a crucial role in managing the execution flow of programs.